+++
title = "Product Recommendations in RedisGraph, Part 3: Query Load Testing"
date = "2020-05-11"
tags = ["graph", "redis", "recommendations", "data", "opencypher", "redisgraph"]
+++

This post is a continuation of the series on leveraging RedisGraph for product recommendations.

The posts in this "series" detail the generation scripts for programmatic and bulk loading of the mock commerce graph/data. This post will
focus on a query load testing tool for Redis Graph.

### Concurrency

Given that [RedisGraph](http://redisgraph.io) is built atop Redis it is single threaded. Things are a little different in Redis 6, but Redis 5.x is
is a [different story](https://redislabs.com/blog/making-redis-concurrent-with-modules/). Queries in RedisGraph happen atomically, but RedisGraph
internally uses a thread pool it uses to keep queries in/out of the essential, globally locked section of the runtime. The query scheduler has incredibly
tiny context switch TTLs resulting in greater performance when some amount of non-lock-requiring work can be done in the threads.

Thus we're able to squeeze a good amount of performance out of RedisGraph by concurrently slamming the instance and the data generated by the
[POC](https://github.com/joshdurbin/redis-graph-commerce-poc) tooling. The tooling I'd like to specifically talk about today is
the [productRecommendationQueryRunner](https://github.com/joshdurbin/redis-graph-commerce-poc/blob/master/productRecommendationQueryRunner). This tool does
just that.

This tool does two things. First, it queries for the `id` property of `person`-labeled nodes ordered by their count of `order`-labeled nodes by
way of the path made possible by the `transact`-typed edge.

```
match
    (p:person)-[:transact]->(o:order)
return
    p.id, count(o) as orders
order by orders desc limit 100
```

The second thing it does is take the `person`-labeled node `id` property and pass that along to a thread pool that then executes the query:

```
match
    (p:person { id: 920 })-[:transact]->(:order)-[:contain]->(prod:product)
match
    (prod)<-[:contain]-(:order)-[:contain]->(rec_prod:product)
where not
    (p)-[:transact]->(:order)-[:contain]->(rec_prod)
return
    distinct rec_prod.id, rec_prod.name
```

...keeping stats on the performance, general counts of things, etc...

### Code

The link to the full source code for the tool is linked above. This code is broken into multiple parts.  

1. CLI builder initializes to setup and provide input verification -- this takes a good number lines of code, unfortunately, but makes things pretty from a user / usability perspective

```groovy
def progressBarUpdateInterval = 200

// defaults must be strings for CliBuilder
def defaultGraphDB = 'prodrec'
def defaultThreadCount = "${new SystemInfo().hardware.processor.physicalProcessorCount}"
def defaultRedisHost = 'localhost'
def defaultRedisPort = '6379'
def defaultTopNumberOfPurchasers = '1000'

def cli = new CliBuilder(header: 'Concurrent RedisGraph Query Runner', usage:'productRecommendationQueryRunner -e <comma delimited environments> <other args>', width: -1)
cli.db(longOpt: 'database', "The RedisGraph database to use for the query [defaults to ${defaultGraphDB}]", args: 1, defaultValue: defaultGraphDB)
cli.tc(longOpt: 'threadCount', "The thread count to use [defaults to ${defaultThreadCount}]", args: 1, defaultValue: defaultThreadCount)
cli.h(longOpt: 'help', 'Usage Information')
cli.rh(longOpt: 'redisHost', "The host of the Redis instance with the RedisGraph module installed to use for graph creation. [defaults to ${defaultRedisHost}]", args: 1, defaultValue: defaultRedisHost)
cli.rp(longOpt: 'redisPort', "The port of the Redis instance with the RedisGraph module installed to use for graph creation. [defaults to ${defaultRedisPort}]", args: 1, defaultValue: defaultRedisPort)
cli.tp(longOpt: 'topPurchasers', "The number of top purchasers to query for [defaults to ${defaultTopNumberOfPurchasers}]", args: 1, defaultValue: defaultTopNumberOfPurchasers)
cli.l(longOpt: 'limitResults', "The default results limit.", args: 1)

// parse and validate options
def cliOptions = cli.parse(args)

def printErr = System.err.&println

if (!cliOptions) {
  cli.usage()
  System.exit(-1)
}

if (cliOptions.help) {
  cli.usage()
  System.exit(0)
}

def db = cliOptions.db

// setup jedis and graph
def threadCount = cliOptions.tc as Integer
def config = new GenericObjectPoolConfig()
config.setMaxTotal(threadCount)
def jedisPool = new JedisPool(config, cliOptions.redisHost, cliOptions.redisPort as Integer)
def redisGraph = new RedisGraph(jedisPool)
```

2. Execute the first query and get the highest number of top purchasers.

```groovy
// query to get the top 1,000 person ids with the most orders
def personIdsToOrderCounts = redisGraph.query(db, "match (p:person)-[:transact]->(o:order) return p.id, count(o) as orders order by orders desc limit ${cliOptions.topPurchasers}")
def personIds = personIdsToOrderCounts.collect {
  it.values.first() as Integer
}
```

3. Definition of basic objects for storage and concurrent queues for thread-safe insertion and polling.

```groovy
// queue is used to track results coming back from the worker threads
 def resultsQueue = new ConcurrentLinkedQueue()
 
 // latch is used to denote to the progress bar when things should be complete
 def latch = new CountDownLatch(threadCount)
 
 @Canonical class RecommendedProducts {
 
   def personId
   def products
   def queryTime
 }
 
 @Canonical class Product {
 
   def id
   def name
 }
 
 // this is used to generate a reaslistic max value for the progressbar
 def expectedNumberOfQueueEntries = personIds.size()
 def queueOfPeopleToQueryForProductRecommendations = new ConcurrentLinkedQueue(personIds.shuffled())
```

4. The meat where we create n threads and run our query to get recommended products for that `person`.

```groovy
// thread generation
threadCount.times {

  Thread.start {

    while (!queueOfPeopleToQueryForProductRecommendations.isEmpty()) {

      def personId = queueOfPeopleToQueryForProductRecommendations.poll()

      try {

        // ask the graph for the product ids and names found in the placed orders of other users who share product purchase histories with a given user, person id
        def query = """match (p:person { id: ${personId} })-[:transact]->(:order)-[:contain]->(prod:product)
                       match (prod)<-[:contain]-(:order)-[:contain]->(rec_prod:product)
                       where not (p)-[:transact]->(:order)-[:contain]->(rec_prod)
                       return distinct rec_prod.id, rec_prod.name"""

        if (cliOptions.limitResults) {
          query += " limit ${cliOptions.limitResults}"  
        }

        def recommendedProductsQuery = redisGraph.query(db, query)
        def recommendedProducts = recommendedProductsQuery.results.collect {
          new Product(it.values().first(), it.values().last())
        }

        // get the query details and offer them to the queue for reporting
        def queryTime = recommendedProductsQuery.statistics.getStringValue(Label.QUERY_INTERNAL_EXECUTION_TIME).takeBefore(' ')
        resultsQueue.offer(new RecommendedProducts(personId, recommendedProducts, queryTime))

      } catch (Exception e ) {
        printErr("error processing ${personId}")
      }
    }

    latch.countDown()
  }
}
```

5. Stitch the results together providing p50, p95, and p99 stats.

```groovy
// counts don't require individual insert tracking, so we use the memory efficient summary stats
def counts = new SummaryStatistics()

// times does require it, so we can get the p50, p95, p99
def times = new DescriptiveStatistics()

new ProgressBar('Progress', expectedNumberOfQueueEntries, progressBarUpdateInterval).withCloseable { progressBar ->

  while (latch.count > 0L) {

    def recommendedProducts = resultsQueue.poll()

    if (recommendedProducts) {

      counts.addValue(recommendedProducts.products.size() as Integer)
      times.addValue(recommendedProducts.queryTime as Double)
      progressBar.step()
    }
  }
}

println "Found a min number of recommended products of ${counts.min as Integer}, avg of ${counts.mean as Integer}, and a max of ${counts.max as Integer} for ${counts.n} with a query performance p50 ${(times.getPercentile(50.0) as String).takeBefore('.')}ms, p95 ${(times.getPercentile(95.0) as String).takeBefore('.')}ms, p99 ${(times.getPercentile(99.0) as String).takeBefore('.')}ms"
```

### Usage

Execuging the runner with a help flag `-h` we get the following output: 

```shell script
./productRecommendationQueryRunner --help
usage: productRecommendationQueryRunner <args>
Concurrent RedisGraph Query Runner
 -db,--database <arg>        The RedisGraph database to use for the query [defaults to prodrec]
 -h,--help                   Usage Information
 -l,--limitResults <arg>     The default results limit.
 -rh,--redisHost <arg>       The host of the Redis instance with the RedisGraph module installed to use for graph creation. [defaults to localhost]
 -rp,--redisPort <arg>       The port of the Redis instance with the RedisGraph module installed to use for graph creation. [defaults to 6379]
 -tc,--threadCount <arg>     The thread count to use [defaults to 6]
 -tp,--topPurchasers <arg>   The number of top purchasers to query for [defaults to 1000]
```